# penspin-calculate

Программа, позволяющая посчитать момент инерции мода. Является неким дополнением к [статье в пенплове](https://vk.com/@penflow-prodvinutoe-ruchkostroenie).

## Где скачать

Можете скачать .exe файл например [тут](https://drive.google.com/drive/folders/1KhLBx6Muxj3hVwqZAvNz8T1gQVk8ChF5?usp=sharing) или может быть [здесь](https://disk.yandex.ru/d/Hiaux1cB3CVJtg). Тогда вам остается просто запустить файл `PenSpinCalculate.exe`. Если ничего из этих ссылок не работает, можете 
написать [мне](https://vk.com/mozhaa).

*Либо вы можете склонировать этот репозиторий и запустить main.py, но для этого вам понадобится Python как минимум версии 3.10 и, возможно, ещё какие-то библиотеки.*

## Как этим пользоваться и зачем

Во-первых, вам нужно будет построить модель мода, который вы хотите посчитать. Как мы знаем, мод состоит из *деталей*, так 
что в программе вы можете добавлять какие-то детали, задавая их *вес* и *длину*. Отмечу, что ***длина и масса детали всегда 
задается в сантиметрах и граммах соответственно***. 

Вес и длину детали можете измерить сами, если она у вас есть, либо взять из 
[таблицы весов и длин](https://docs.google.com/spreadsheets/d/1hcoKoxpsKErape9xDHWiMErspsXQS4bGGeomv4eP0K4/edit#gid=475572764). 
К сожалению, у типов там длина не обозначена, так что придется либо мерить её самому, либо ставить наугад.

### Неточность

Собственно, пока что это все, что вы можете задать у детали, и отсюда возникает проблема в **неточности** всего этого подсчета, 
так как например у какого-нибудь условного ДГ типа, вес распределен не равномерно по всей длине, а все детали считаются с равномерным 
распределением веса. Если вы очень хотите посчитать точно, вы можете разделить одну деталь на несколько поддеталей так, чтобы в сумме 
масса и длина была такой же, но распределить вес по ним как вам угодно. Это очень муторно, но как есть. 

Из всего этого можно сделать вывод, что в целом программа не имеет никакого практического применения, кроме как посидеть и 
посравнивать какие-то моды (что в целом на достаточно опытный глаз и так ясно), либо показать новичкам, в чем именно разница 
между хорошим распределением веса и плохим.

## Интерфейс

Интерфейс тут не очень богатый, как и функционал в целом, потому что не вижу смысла расширять это до чего-то более серьезного. 
Но давайте рассмотрим основные компоненты программы:

![Скриншот](https://sun9-86.userapi.com/impg/IxAhvUQEy9-RmXEwy8ZO9RRb1YRDyNmgkzRSDQ/JxobcqvleEk.jpg?size=1022x624&quality=96&sign=7a82fa69c1763ac3f0c29b9d5c348f58&type=album) 

Как только мы запускаем наш `penspin_calculate.exe` файл, появляется 2 окна: *консоль* и второе окно. В *консоли* мы ничего 
 писать не будем и не сможем, там будет только выводиться что-то, что нам будет нужно.

Второе окно (оно имеет название "PenSpin Calculate") это то окно, в котором мы и будем работать, там есть: *строка для ввода команды*, *кнопка* и *панель*, на которой 
будет показываться модель нашего мода. На панели сразу появляется черная линия ровно посередине и красный отрезочек в центре этой линии.
Так как мод это всегда какая-то палка с весами в разных частях этой палки, у нас есть ось (черная прямая), на которой и будут 
появляться наши детали.

Красный отрезочек в центре это **_нулевая координата_**. Она всегда будет оставаться в центре окна, поэтому удобно распологать 
все детали примерно рядом с ней, вокруг неё. Замечу, что вы не обязаны делать так, чтобы эта точка была центром масс вашего мода, 
потому что программа все равно посчитает момент инерции мода относительно не этой точки, а центра масс, что вполне логично.

Почти все взаимодействие с программой происходит посредством печати какой-либо команды в *строку для ввода команды* и нажатия **<_Enter_>**, 
чтобы эта команда попробовала выполниться.

## Пример использования

**1. Создание деталей**

Попробуем написать в *строку для ввода* команду `add dgg 4.3 5.15 #F1C40F` и нажать **<Enter>**. Во-первых, строка должна стать пустой, а на *панели* 
должен был появиться прямоугольника привычного для ДГГ цвета ~мочи~. Этот прямоугольник и обозначает деталь, а именно ДГГ с массой 4.3 грамма и 
длиной 5.15 сантиметра. Эти числа я взял не с неба, а из **таблицы весов и длин**. Так же над ним написано имя детали, для удобства. Заметим, что 
как только мы создали первую деталь, на оси появилась новая *зеленая* точка, которая обозначает центр масс всей нашей модели.

![Скриншот](https://sun9-57.userapi.com/impg/_D9e-zrHx3rnb_4SXOH34gJWhQNDveriIbh9Ng/0toQoxIEbrg.jpg?size=1022x610&quality=96&sign=deae6aa3a2472a5b58217320d7c1738f&type=album)

Теперь, допустим, мы хотим сделать комссу с половинками дгг по краям. Для этого давайте добавим саму основу комссу и комсса кэпы:
```
add comssa 6.7 11.9
add cap1 1.12 4.1
```
Теперь, так как нам нужен второй кэп, а он по характеристикам в точности такой же как и первый, его можно *скопировать* с первого с помощью команды 
`copy cap1 cap2`. Тогда мы создадим ещё одну деталь с именем **_cap2_** и с точно теми же характеристиками, что и у **_cap1_**.

![Скриншот](https://sun9-81.userapi.com/impg/c9FFbBMmU-xgA4POHJOjv2TY8opUbZQosdBAkg/Bb9hYs8BSM0.jpg?size=1016x609&quality=96&sign=fc8caa5b1cd6e9a3bb6540a76b7eb4d3&type=album)

**2. Разрезание детали**

Теперь, **с точки зрения деталей**, нам осталось только разделить наш ДГГ на 2 равные половинки. К счастью, ничего резать не нужно, 
а результат получится идеально ровным, если использовать для этого команду `cut dgg 1/1`. Таким образом, наша изначальная деталь **_dgg_** разделилась 
на две равные с точки зрения массы и длины, а имена им были присвоены автоматически **_dgg1_** и **_dgg2_** (то есть имя первой детали = изначальное имя + 1, 
а имя второй = изначальное имя + 2). Можно указать имена деталей в конце команды вручную, например так: 
```
cut dgg 1/1 dgg_left dgg_right
```
**_1/1_** в команде означает, 
что мы хотим разрезать деталь в отношениее один к одному. Если бы мы написали 2/3, то она бы разделилась в отношении два к трем. Также можно задать не отношение, 
в котором надо разрезать деталь, а точную длину в сантиметрах, которую необходимо отрезать от детали. Так, например, `cut dgg 4 dgg4cm dggother` в результате 
создаст две детали с именами **_dgg4cm_** и **_dggother_**, при чем деталь **_dgg4cm_** будет иметь длину 4 см, а **_dggother_** оставшуюся, то есть 1.15 см.

![Скриншот](https://sun9-1.userapi.com/impg/xaALGq9napWpBdvzmjSST_66p3XD5i-mK_hXYQ/QrsEfCKYq54.jpg?size=1234x264&quality=96&sign=c709ab76267fba6c341dfb4874f17fb3&type=album)

**3. Перемещение деталей**

Теперь нам осталось только передвинуть кэпы по краям основы, а половинки ДГГ по краям кэпов. Для начала давайте для удобства сдвинем основу comssa в центр оси, 
чтобы нам было удобно смотреть на мод. Для этого напишем команду `move comssa center`. **_center_** в данном случае означает, что деталь сдвинется так, 
чтобы её середина совпадала с нулевой координатой оси. В привычном использовании команды **_move_**, мы будем писать числовое значение, на которое нужно сдвинуть 
деталь (например `move dgg 1.5`), а для сдвига влево будем писать отрицательное значение (например, `move dgg -0.6`).

Теперь, так как нам очень неудобно было бы считать вручную числовые значения для того, чтобы поставить кэпы по краям основы, мы воспользуемся другой 
командой для сдвига деталей. Напишем `select cap1` и тогда деталь **_cap1_** выделиться красным (это может быть незаметно из-за количество перекрывающих деталей). 
Далее нажимаем либо **<_Tab_>** либо **<_F1_>** и после этого голубая кнопка справа от строки ввода должна стать более яркой, синей. Таким образом, 
мы включили *режим движения*. 

В этом режиме двигать детали можно с помощью **<_Left_>/<_Right_>** (стрелочки влево/вправо), либо с помощью кнопок **<_a_>/<_d_>** соответственно. Простые нажатия 
**<_Left_>/<_a_>** вызывают так называемый *нормальный шаг*, при котором деталь сдвигается на 1 см влево. Нажатия **<_Shift+Left_>/<_Shift+a_>** вызывают 
так называемые *короткие шаги*, при котором деталь сдвигается на 0.1 см (1 мм) влево. И третий, самый интересный вариант движения вызывается при нажатии 
**<_Ctrl+Left_>/<_Ctrl+a_>** - деталь сдвигается к ближайшему краю какой-либо детали слева. Это очень удобно, например, если мы хотим сдвинуть кэп так, чтобы 
он слева примыкал к основе.

Попробуем несколько раз нажать **<_Ctrl+Left_>/<_Ctrl+a_>** или **<_Ctrl+Right_>/<_Ctrl+d_>**. Найдем такое положение, при котором **_cap1_** лежит точно слева 
от основы **_comssa_** и примыкает к ней. Потом, как только мы закончим, нажмем снова **<_Tab_>/<_F1_>**, тем самым переключаясь на строку ввода. Теперь напишем 
`select cap2` и снова понажимаем  **<_Ctrl+Left_>/<_Ctrl+a_>** и **<_Ctrl+Right_>/<_Ctrl+d_>**, добиваясь того, чтобы он примыкал к основе справа.

![gif](https://sun9-8.userapi.com/c534536/u96138376/docs/d47/792636bfea4c/tutorial.gif?extra=JfQmVcg5sfSKKbGqPg4sWqfkBnNOOTyfphOKQ5v0Ta4HHmPeFYULu3eJOkwOjBQ1b-9se5rRFB-2gOYc_jm_B-DsB-kUqo9MVOdjUWNnD7qJlHyFuzupGn5LhJ9tFXCh_Lgc8WU8FxwLMJtiREsd)

**4. Подсчет момента инерции текущей модели**

Как только мы передвинули все детали на нужные места, у нас получилась готовая модель мода. Теперь мы хотим посчитать его момент инерции. Для этого 
напишем в строку ввода команду `calculate` и в *консоль* выведется число, которое и является моментом инерции данной модели в **г*см^2**. В данном случае у нас 
получилось примерно 557 г*см^2, что например примерно в 2 раза меньше чем момент инерции бастера (вполне логично).

![Скриншот](https://sun9-19.userapi.com/impg/x0FNAtmiatZYFJO0cDSvPdguHmwzlmf_Q-2-ZA/3fqUJMbb_SY.jpg?size=1080x633&quality=96&sign=04a496395a933607a94df6a5f22cd9dc&type=album)

### Сохранение

**1. Сохранение моделей**

Модель можно сохранить в файл с помощью команды - `save <filename>` (можно указать расширение файла, можно не указывать, это ничего не меняет, но лучше не указывать). 
Все сохраненные модели хранятся в папке *files/* и если надо, их можно будет загрузить в другой сессии программы с помощью команды `load <filename>`. Некоторые 
модели уже готовые, можете посмотреть папку *files/*

**2. Сохранение деталей**

Также можно сохранить деталь в файл *listed.json* с помощью команды `listed save <detail_name> <name_to_file>` и тогда в файл запишется сведения о детали с именем
*detail_name* (имя, характеристики, но цвет не сохраняется), но сохранится с именем *name_to_file*. Тогда позже можно будет загрузить деталь из файла с помощью команды 
`listed load <name_from_file> <detail_name> [color]` и тогда из файла загрузится деталь, которая туда сохранена под именем *name_from_file*, и она добавится 
в текущую модель, но уже под именем *detail_name*. Также можно задать цвет детали. В файле *listed.json* уже есть некоторые детали, так что можете посмотреть их 
с помощью `listed print`.

### Ошибки

Вообще, если написать команду неверно, то есть, например, ошибится в аргументах (`add dgg`), то в консоль должна вывестись ошибка, в которой будет примерно написана причина 
невалидности команды. Но если, например, ошибится в орфографии названия команды (`lsited load dgg dgg`), то в консоль не выведется ничего и ничего не произойдет. 

Я надеюсь, что многие ошибки обработаны, и если вы где-то ошибетесь, то вам в лучшем случае выведется в консоль проблема, а в худшем ничего не произойдет. Но 
я не могу быть точно увереным, что нет какой-нибудь команды, после которой программа может и вовсе вылететь, так что будьте аккуратны.

## Команды

В программе реализовано достаточное количество разных комманд. У каждой команды есть название, после которой идут аргументы. 
Какие-то аргументы заключены в угловые скобки ( **<имя>** ), а какие-то в квадратные скобки ( **[цвет]** ). Угловые скобки означают, что аргумент обязателен 
при использовании команды и его необходимо задать, а квадратные скобки означают, что аргумент необязателен и если его не задать, то значение задастся автоматически.

- `help` - выводит в *консоль* список комманд с необходимыми аргументами к ним
- `add <имя> <масса> <длина> [цвет]` - добавляет новую деталь с именем **<_имя_>**, массой **<_масса_>**, длиной **<_длина_>** и *если указан*, то цветом **[_цвет_]**
- `move <имя> <расстояние>` - сдвигает деталь с именем **<_имя_>** на расстояние **<_расстояние_>**. Если расстояние положительное, то сдвиг происходит вправо, 
если отрицательно, то влево. Также можно задать вместо аргумента **<_расстояние_>** не число, а параметр *center*, и тогда деталь переместится так, что её центр совпадет с нулевой координатой. И ещё можно сдвинуть сразу несколько деталей на одинаковое расстояние, если написать, например `move cap1 cap2 dgg1 dgg2 2.5`
- `move_to <имя> <позиция>` - перемещает деталь с именем **<_имя_>** на координату **<_позиция_>**. Также можно задать вместо аргумента **<_позиция_>** не число, 
а параметр *center*, и тогда деталь переместится так, что её центр совпадет с нулевой координатой
- `rename <старое имя> <новое имя>` - переименовывает деталь с именем **<_старое имя_>** на имя **<_новое имя_>**
- `copy <имя1> <имя2>` - создает деталь с именем **<_имя2_>** и характеристиками точно такими же, как и у детали с именем **<_имя1_>**
- `edit <имя> <mass/length/color> <новое значение>` - редактирует характеристику **<_mass_/_length_/_color_>** детали с именем **<_имя_>** на **<_новое значение_>**
- `cut <имя> <длина или отношение> [имя1] [имя2]` - режет деталь с именем **<_имя_>** в отношении **<_отношение_>** и полученные две детали называет именами 
**[_имя1_]** и **[_имя2_]**. Если вместо отношения обозначена длина (то есть нет символа '/'), то отрезает от изначальной детали, деталь длины **<_длина_>** и 
деталь оставшейся длины
- `select <имя>` - выделяет деталь с именем **_<имя>_**, после чего её можно двигать в *режиме движения* с помощью (**_<Ctrl+>_** или **_<Shift+>_**) **<_Left_>/<_Right_>** (стрелочки влево/вправо), 
либо с помощью кнопок (**_<Ctrl+>_** или **_<Shift+>_**) **<_a_>/<_d_>**.
- `deselect` - снимает выделение с детали, если такое имеется
- `remove <имя>` - удаляет деталь с именем **<_имя_>**
- `listed load <название> <имя> [цвет]` - загружает деталь из файла *listed.json* с названием **<_название_>** и добавляет её в текущую модель как деталь с 
именем **_<имя>_** и цветом **[_цвет_]**
- `listed print` - выводит в консоль все детали по названиям, которые содержатся в файле *listed.json* 
- `listed show <название>` - выводит в консоль характеристики детали из файла *listed.json* с названием **<_название_>**
- `listed save <имя> [название]` - сохраняет уже существующую деталь с именем **<_имя_>** в файл *listed.json* с названием **[_название_]**. Если название не указано, 
то сохраняет с именем **<_имя_>**
- `listed remove <название>` - удаляет из файла *listed.json* деталь с названием **<_название_>**
- `print <имя>` - печатает в *консоль* характеристики детали с именем **<_имя_>**
- `dist <l/r> <имя1> <l/r> <имя2>` - считает расстояние между **_l_** - левым/**_r_** - правым концом детали с именем **<_имя1_>** и 
**_l_** - левым/**_r_** - правым концом детали с именем **<_имя2_>**
- `list` - пишет в *консоль* список всех деталей с их характеристиками
- `calculate` - считает момент инерции текущей модели и выводит его в *консоль*
- `save <название файла>` - сохраняет текущую модель в файл с названием **<_название файла_>** (он хранится в папке */files*)
- `load <название файла>` - загружает модель из файла с названием **<_название файла_>**, в котором содержится сохраненная модель
- `clear` - удаляет все детали с модели
- `exit` - выход из программы

